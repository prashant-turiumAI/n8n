import { Service } from '@n8n/di';
import { Logger } from '@n8n/backend-common';
import type { IWorkflowExecutionDataProcess } from 'n8n-workflow';
import type { WorkflowHandle } from '@temporalio/client';

// Type for workflow history returned by fetchHistory()
type TemporalHistory = Awaited<ReturnType<WorkflowHandle['fetchHistory']>>;
import { TemporalClientService } from './temporal-client.service';
import { TemporalConfig, GlobalConfig } from '@n8n/config';
// Import workflow directly from source (workspace package)
import { n8nWorkflowExecution } from '@n8n/temporal-worker/src/workflows';
import { UrlService } from '@/services/url.service';

/**
 * Service for executing workflows via Temporal.
 * Handles starting workflows and querying execution history.
 */
@Service()
export class TemporalExecutionService {
	constructor(
		private readonly temporalClient: TemporalClientService,
		private readonly temporalConfig: TemporalConfig,
		private readonly globalConfig: GlobalConfig,
		private readonly urlService: UrlService,
		private readonly logger: Logger,
	) {}

	/**
	 * Starts a Temporal workflow for the given execution data.
	 * @param executionData - The workflow execution data
	 * @param executionId - The n8n execution ID (generated by ActiveExecutions)
	 * @returns Temporal workflow ID and run ID
	 */
	async startWorkflow(
		executionData: IWorkflowExecutionDataProcess,
		executionId: string,
	): Promise<{ workflowId: string; runId: string }> {
		const client = await this.temporalClient.connect();

		// Generate unique Temporal workflow ID
		// Format: n8n-{workflowId}-{timestamp}
		const workflowId = `n8n-${executionData.workflowData.id || 'unknown'}-${Date.now()}`;

		try {
			// Get n8n API base URL for credential resolution
			const n8nApiUrl = this.urlService.getInstanceBaseUrl();

			const handle = await client.workflow.start(n8nWorkflowExecution, {
				args: [
					{
						executionData,
						executionId,
						n8nApiUrl,
						workerSecret: this.temporalConfig.workerCredentialSecret,
					},
				],
				taskQueue: this.temporalConfig.taskQueue,
				workflowId,
				workflowExecutionTimeout: '1h',
				workflowRunTimeout: '1h',
			});

			this.logger.info('Started Temporal workflow', {
				workflowId: handle.workflowId,
				runId: handle.firstExecutionRunId,
				n8nExecutionId: executionId,
			});

			return {
				workflowId: handle.workflowId,
				runId: handle.firstExecutionRunId,
			};
		} catch (error) {
			this.logger.error('Failed to start Temporal workflow', {
				error,
				errorMessage: error instanceof Error ? error.message : String(error),
				errorStack: error instanceof Error ? error.stack : undefined,
				n8nExecutionId: executionId,
				workflowId: executionData.workflowData.id,
				temporalHost: this.temporalConfig.host,
				temporalNamespace: this.temporalConfig.namespace,
				taskQueue: this.temporalConfig.taskQueue,
			});
			throw error;
		}
	}

	/**
	 * Fetches the execution history for a Temporal workflow.
	 * @param workflowId - The Temporal workflow ID
	 * @returns Workflow execution history
	 */
	async getWorkflowHistory(workflowId: string): Promise<TemporalHistory> {
		const client = await this.temporalClient.connect();
		const handle = client.workflow.getHandle(workflowId);
		const history = await handle.fetchHistory();
		return history;
	}

	/**
	 * Gets the result of a completed Temporal workflow.
	 * @param workflowId - The Temporal workflow ID
	 * @returns Workflow execution result
	 */
	async getWorkflowResult<T = unknown>(workflowId: string): Promise<T> {
		const client = await this.temporalClient.connect();
		const handle = client.workflow.getHandle(workflowId);
		return await handle.result();
	}
}
